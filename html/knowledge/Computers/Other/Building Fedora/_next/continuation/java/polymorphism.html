<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 TRANSITIONAL//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Fedora Server Installation</title>
    <link
      rel="stylesheet"
      type="text/css"
      media="screen,print"
      href="/stylesheets/Welcome./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="/stylesheets/install./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="./install./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="../install./css/fedora_install.css"
    />
    <meta status="incomplete" />
  </head>
  <body>
    <h2><a>Default</a></h2>

    <!-- PRINTING STARTS HERE -->
    <div class="content">
      <h1>Java - Polymorphism</h1>
      <div class="topgooglead">
        <div style="padding-bottom: 5px; padding-left: 10px">
          Advertisements
        </div>
        <script type="text/javascript">
          <!--
          google_ad_client = "pub-7133395778201029";
          google_ad_width = 468;
          google_ad_height = 60;
          google_ad_format = "468x60_as";
          google_ad_type = "image";
          google_ad_channel = "";
          //-->
        </script>
        <script
          type="text/javascript"
          src="http://pagead2.googlesyndication.com/pagead/show_ads.js"
        ></script>
      </div>
      <hr />
      <div class="pre-btn">
        <a href="/java/java_overriding.htm">Previous Page</a>
      </div>
      <div class="nxt-btn">
        <a href="/java/java_abstraction.htm">Next Page</a>
      </div>
      <div class="clearer"></div>
      <hr />
      <p>
        Polymorphism is the ability of an object to take on many forms. The most
        common use of polymorphism in OOP occurs when a parent class reference
        is used to refer to a child class object.
      </p>
      <p>
        Any java object that can pass more than one IS-A test is considered to
        be polymorphic. In Java, all java objects are polymorphic since any
        object will pass the IS-A test for their own type and for the class
        Object.
      </p>
      <p>
        It is important to know that the only possible way to access an object
        is through a reference variable. A reference variable can be of only one
        type. Once declared the type of a reference variable cannot be changed.
      </p>
      <p>
        The reference variable can be reassigned to other objects provided that
        it is not declared final. The type of the reference variable would
        determine the methods that it can invoke on the object.
      </p>
      <p>
        A reference variable can refer to any object of its declared type or any
        subtype of its declared type. A reference variable can be declared as a
        class or interface type.
      </p>
      <h2>Example:</h2>
      <p>Let us look at an example.</p>
      <pre class="prettyprint">
public interface Vegetarian{}
public class Animal{}
public class Deer extends Animal implements Vegetarian{}
</pre
      >
      <p>
        Now the Deer class is considered to be polymorphic since this has
        multiple inheritance. Following are true for the above example:
      </p>
      <ul class="list">
        <li><p>A Deer IS-A Animal</p></li>
        <li><p>A Deer IS-A Vegetarian</p></li>
        <li><p>A Deer IS-A Deer</p></li>
        <li><p>A Deer IS-A Object</p></li>
      </ul>
      <p>
        When we apply the reference variable facts to a Deer object reference,
        the following declarations are legal:
      </p>
      <pre class="prettyprint">
Deer d = new Deer();
Animal a = d;
Vegetarian v = d;
Object o = d;
</pre
      >
      <p>
        All the reference variables d,a,v,o refer to the same Deer object in the
        heap.
      </p>
      <h2>Virtual Methods:</h2>
      <p>
        In this section, I will show you how the behavior of overridden methods
        in Java allows you to take advantage of polymorphism when designing your
        classes.
      </p>
      <p>
        We already have discussed method overriding, where a child class can
        override a method in its parent. An overridden method is essentially
        hidden in the parent class, and is not invoked unless the child class
        uses the super keyword within the overriding method.
      </p>
      <pre class="prettyprint">
/* File name : Employee.java */
public class Employee
{
   private String name;
   private String address;
   private int number;
   public Employee(String name, String address, int number)
   {
      System.out.println("Constructing an Employee");
      this.name = name;
      this.address = address;
      this.number = number;
   }
   public void mailCheck()
   {
      System.out.println("Mailing a check to " + this.name
       + " " + this.address);
   }
   public String toString()
   {
      return name + " " + address + " " + number;
   }
   public String getName()
   {
      return name;
   }
   public String getAddress()
   {
      return address;
   }
   public void setAddress(String newAddress)
   {
      address = newAddress;
   }
   public int getNumber()
   {
     return number;
   }
}
</pre
      >
      <p>Now suppose we extend Employee class as follows:</p>
      <pre class="prettyprint">
/* File name : Salary.java */
public class Salary extends Employee
{
   private double salary; //Annual salary
   public Salary(String name, String address, int number, double
      salary)
   {
       super(name, address, number);
       setSalary(salary);
   }
   public void mailCheck()
   {
       System.out.println("Within mailCheck of Salary class ");
       System.out.println("Mailing check to " + getName()
       + " with salary " + salary);
   }
   public double getSalary()
   {
       return salary;
   }
   public void setSalary(double newSalary)
   {
       if(newSalary &gt;= 0.0)
       {
          salary = newSalary;
       }
   }
   public double computePay()
   {
      System.out.println("Computing salary pay for " + getName());
      return salary/52;
   }
}
</pre
      >
      <p>
        Now you study the following program carefully and try to determine its
        output:
      </p>
      <pre class="prettyprint">
/* File name : VirtualDemo.java */
public class VirtualDemo
{
   public static void main(String [] args)
   {
      Salary s = new Salary("Mohd Mohtashim", "Ambehta,  UP",
                                 3, 3600.00);
      Employee e = new Salary("John Adams", "Boston, MA",
                                 2, 2400.00);
      System.out.println("Call mailCheck using 
                                   Salary reference --");
      s.mailCheck();
      System.out.println("\n Call mailCheck using 
                                   Employee reference--");
      e.mailCheck();
    }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
Constructing an Employee
Constructing an Employee
Call mailCheck using Salary reference --
Within mailCheck of Salary class
Mailing check to Mohd Mohtashim with salary 3600.0

Call mailCheck using Employee reference--
Within mailCheck of Salary class
Mailing check to John Adams with salary 2400.0
</pre
      >
      <p>
        Here we instantiate two Salary objects . one using a Salary reference s,
        and the other using an Employee reference e.
      </p>
      <p>
        While invoking <i>s.mailCheck()</i> the compiler sees mailCheck() in the
        Salary class at compile time, and the JVM invokes mailCheck() in the
        Salary class at run time.
      </p>
      <p>
        Invoking mailCheck() on e is quite different because e is an Employee
        reference. When the compiler sees<i>e.mailCheck()</i>, the compiler sees
        the mailCheck() method in the Employee class.
      </p>
      <p>
        Here, at compile time, the compiler used mailCheck() in Employee to
        validate this statement. At run time, however, the JVM invokes
        mailCheck() in the Salary class.
      </p>
      <p>
        This behavior is referred to as virtual method invocation, and the
        methods are referred to as virtual methods. All methods in Java behave
        in this manner, whereby an overridden method is invoked at run time, no
        matter what data type the reference is that was used in the source code
        at compile time.
      </p>
      <br />
      <hr />
      <div class="pre-btn">
        <a href="/java/java_overriding.htm">Previous Page</a>
      </div>
      <div class="print-btn">
        <a href="/cgi-bin/printpage.cgi" target="_blank">Print Version</a>
      </div>
      <div class="pdf-btn">
        <a
          href="/java/pdf/java_polymorphism.pdf"
          alt="Java - Polymorphism"
          target="_blank"
          >PDF Version</a
        >
      </div>
      <div class="nxt-btn">
        <a href="/java/java_abstraction.htm">Next Page</a>
      </div>
      <div class="clearer"></div>
      <hr />
    </div>
    <!-- PRINTING ENDS HERE -->
  </body>
</html>
