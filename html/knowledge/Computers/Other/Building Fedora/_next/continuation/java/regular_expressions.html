<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 TRANSITIONAL//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Fedora Server Installation</title>
    <link
      rel="stylesheet"
      type="text/css"
      media="screen,print"
      href="/stylesheets/Welcome./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="/stylesheets/install./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="./install./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="../install./css/fedora_install.css"
    />
    <meta status="incomplete" />
  </head>
  <body>
    <h2><a>Default</a></h2>

    <!-- PRINTING STARTS HERE -->
    <div class="content">
      <h1>Java - Regular Expressions</h1>
      <div class="topgooglead">
        <div style="padding-bottom: 5px; padding-left: 10px">
          Advertisements
        </div>
        <script type="text/javascript">
          <!--
          google_ad_client = "pub-7133395778201029";
          google_ad_width = 468;
          google_ad_height = 60;
          google_ad_format = "468x60_as";
          google_ad_type = "image";
          google_ad_channel = "";
          //-->
        </script>
        <script
          type="text/javascript"
          src="http://pagead2.googlesyndication.com/pagead/show_ads.js"
        ></script>
      </div>
      <hr />
      <div class="pre-btn">
        <a href="/java/java_date_time.htm">Previous Page</a>
      </div>
      <div class="nxt-btn">
        <a href="/java/java_methods.htm">Next Page</a>
      </div>
      <div class="clearer"></div>
      <hr />
      <p>
        Java provides the java.util.regex package for pattern matching with
        regular expressions. Java regular expressions are very similar to the
        Perl programming language and very easy to learn.
      </p>
      <p>
        A regular expression is a special sequence of characters that helps you
        match or find other strings or sets of strings, using a specialized
        syntax held in a pattern. They can be used to search, edit, or
        manipulate text and data.
      </p>
      <p>
        The java.util.regex package primarily consists of the following three
        classes:
      </p>
      <ul class="list">
        <li>
          <p>
            <b>Pattern Class:</b> A Pattern object is a compiled representation
            of a regular expression. The Pattern class provides no public
            constructors. To create a pattern, you must first invoke one of its
            public static compile methods, which will then return a Pattern
            object. These methods accept a regular expression as the first
            argument.
          </p>
        </li>
        <li>
          <p>
            <b>Matcher Class:</b> A Matcher object is the engine that interprets
            the pattern and performs match operations against an input string.
            Like the Pattern class, Matcher defines no public constructors. You
            obtain a Matcher object by invoking the matcher method on a Pattern
            object.
          </p>
        </li>
        <li>
          <p>
            <b>PatternSyntaxException:</b> A PatternSyntaxException object is an
            unchecked exception that indicates a syntax error in a regular
            expression pattern.
          </p>
        </li>
      </ul>
      <h2>Capturing Groups:</h2>
      <p>
        Capturing groups are a way to treat multiple characters as a single
        unit. They are created by placing the characters to be grouped inside a
        set of parentheses. For example, the regular expression (dog) creates a
        single group containing the letters "d", "o", and "g".
      </p>
      <p>
        Capturing groups are numbered by counting their opening parentheses from
        left to right. In the expression ((A)(B(C))), for example, there are
        four such groups:
      </p>
      <ul class="list">
        <li><p>((A)(B(C)))</p></li>
        <li><p>(A)</p></li>
        <li><p>(B(C))</p></li>
        <li><p>(C)</p></li>
      </ul>
      <p>
        To find out how many groups are present in the expression, call the
        groupCount method on a matcher object. The groupCount method returns an
        int showing the number of capturing groups present in the matcher's
        pattern.
      </p>
      <p>
        There is also a special group, group 0, which always represents the
        entire expression. This group is not included in the total reported by
        groupCount.
      </p>
      <h2>Example:</h2>
      <p>
        Following example illustrate how to find a digit string from the given
        alphanumeric string:
      </p>
      <pre class="prettyprint">
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches
{
    public static void main( String args[] ){

      // String to be scanned to find the pattern.
      String line = "This order was places for QT3000! OK?";
      String pattern = "(.*)(\\d+)(.*)";

      // Create a Pattern object
      Pattern r = Pattern.compile(pattern);

      // Now create matcher object.
      Matcher m = r.matcher(line);
      if (m.find( )) {
         System.out.println("Found value: " + m.group(0) );
         System.out.println("Found value: " + m.group(1) );
         System.out.println("Found value: " + m.group(2) );
      } else {
         System.out.println("NO MATCH");
      }
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
Found value: This order was places for QT3000! OK?
Found value: This order was places for QT300
Found value: 0
</pre
      >
      <h2>Regular Expression Syntax:</h2>
      <p>
        Here is the table listing down all the regular expression metacharacter
        syntax available in Java:
      </p>
      <table class="src">
        <tr>
          <th>Subexpression</th>
          <th>Matches</th>
        </tr>
        <tr>
          <td>^</td>
          <td>Matches beginning of line.</td>
        </tr>
        <tr>
          <td>$</td>
          <td>Matches end of line.</td>
        </tr>
        <tr>
          <td>.</td>
          <td>
            Matches any single character except newline. Using m option allows
            it to match newline as well.
          </td>
        </tr>
        <tr>
          <td>[...]</td>
          <td>Matches any single character in brackets.</td>
        </tr>
        <tr>
          <td>[^...]</td>
          <td>Matches any single character not in brackets</td>
        </tr>
        <tr>
          <td>\A</td>
          <td>Beginning of entire string</td>
        </tr>
        <tr>
          <td>\z</td>
          <td>End of entire string</td>
        </tr>
        <tr>
          <td>\Z</td>
          <td>End of entire string except allowable final line terminator.</td>
        </tr>
        <tr>
          <td>re*</td>
          <td>Matches 0 or more occurrences of preceding expression.</td>
        </tr>
        <tr>
          <td>re+</td>
          <td>Matches 1 or more of the previous thing</td>
        </tr>
        <tr>
          <td>re?</td>
          <td>Matches 0 or 1 occurrence of preceding expression.</td>
        </tr>
        <tr>
          <td>re{ n}</td>
          <td>
            Matches exactly n number of occurrences of preceding expression.
          </td>
        </tr>
        <tr>
          <td>re{ n,}</td>
          <td>Matches n or more occurrences of preceding expression.</td>
        </tr>
        <tr>
          <td>re{ n, m}</td>
          <td>
            Matches at least n and at most m occurrences of preceding
            expression.
          </td>
        </tr>
        <tr>
          <td>a| b</td>
          <td>Matches either a or b.</td>
        </tr>
        <tr>
          <td>(re)</td>
          <td>Groups regular expressions and remembers matched text.</td>
        </tr>
        <tr>
          <td>(?: re)</td>
          <td>Groups regular expressions without remembering matched text.</td>
        </tr>
        <tr>
          <td>(?&gt; re)</td>
          <td>Matches independent pattern without backtracking.</td>
        </tr>
        <tr>
          <td>\w</td>
          <td>Matches word characters.</td>
        </tr>
        <tr>
          <td>\W</td>
          <td>Matches nonword characters.</td>
        </tr>
        <tr>
          <td>\s</td>
          <td>Matches whitespace. Equivalent to [\t\n\r\f].</td>
        </tr>
        <tr>
          <td>\S</td>
          <td>Matches nonwhitespace.</td>
        </tr>
        <tr>
          <td>\d</td>
          <td>Matches digits. Equivalent to [0-9].</td>
        </tr>
        <tr>
          <td>\D</td>
          <td>Matches nondigits.</td>
        </tr>
        <tr>
          <td>\A</td>
          <td>Matches beginning of string.</td>
        </tr>
        <tr>
          <td>\Z</td>
          <td>
            Matches end of string. If a newline exists, it matches just before
            newline.
          </td>
        </tr>
        <tr>
          <td>\z</td>
          <td>Matches end of string.</td>
        </tr>
        <tr>
          <td>\G</td>
          <td>Matches point where last match finished.</td>
        </tr>
        <tr>
          <td>\n</td>
          <td>Back-reference to capture group number "n"</td>
        </tr>
        <tr>
          <td>\b</td>
          <td>
            Matches word boundaries when outside brackets. Matches backspace
            (0x08) when inside brackets.
          </td>
        </tr>
        <tr>
          <td>\B</td>
          <td>Matches nonword boundaries.</td>
        </tr>
        <tr>
          <td>\n, \t, etc.</td>
          <td>Matches newlines, carriage returns, tabs, etc.</td>
        </tr>
        <tr>
          <td>\Q</td>
          <td>Escape (quote) all characters up to \E</td>
        </tr>
        <tr>
          <td>\E</td>
          <td>Ends quoting begun with \Q</td>
        </tr>
      </table>
      <h2>Methods of the Matcher Class:</h2>
      <p>Here is the lists of useful instance methods:</p>
      <h2>Index Methods:</h2>
      <p>
        Index methods provide useful index values that show precisely where the
        match was found in the input string:
      </p>
      <table class="src">
        <tr>
          <th>SN</th>
          <th>Methods with Description</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b>public int start() </b><br />Returns the start index of the
            previous match.
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <b>public int start(int group)</b><br />Returns the start index of
            the subsequence captured by the given group during the previous
            match operation.
          </td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>public int end()</b><br />Returns the offset after the last
            character matched.
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>public int end(int group)</b><br />Returns the offset after the
            last character of the subsequence captured by the given group during
            the previous match operation.
          </td>
        </tr>
      </table>
      <h2>Study Methods:</h2>
      <p>
        Study methods review the input string and return a boolean indicating
        whether or not the pattern is found:
      </p>
      <table class="src">
        <tr>
          <th>SN</th>
          <th>Methods with Description</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b>public boolean lookingAt() </b><br />Attempts to match the input
            sequence, starting at the beginning of the region, against the
            pattern.
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <b>public boolean find() </b><br />Attempts to find the next
            subsequence of the input sequence that matches the pattern.
          </td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>public boolean find(int start</b><br />Resets this matcher and
            then attempts to find the next subsequence of the input sequence
            that matches the pattern, starting at the specified index.
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>public boolean matches() </b><br />Attempts to match the entire
            region against the pattern.
          </td>
        </tr>
      </table>
      <h2>Replacement Methods:</h2>
      <p>
        Replacement methods are useful methods for replacing text in an input
        string:
      </p>
      <table class="src">
        <tr>
          <th>SN</th>
          <th>Methods with Description</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b
              >public Matcher appendReplacement(StringBuffer sb, String
              replacement)</b
            ><br />Implements a non-terminal append-and-replace step.
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <b>public StringBuffer appendTail(StringBuffer sb)</b
            ><br />Implements a terminal append-and-replace step.
          </td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>public String replaceAll(String replacement) </b><br />Replaces
            every subsequence of the input sequence that matches the pattern
            with the given replacement string.
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>public String replaceFirst(String replacement)</b><br />Replaces
            the first subsequence of the input sequence that matches the pattern
            with the given replacement string.
          </td>
        </tr>
        <tr>
          <td>5</td>
          <td>
            <b>public static String quoteReplacement(String s)</b><br />Returns
            a literal replacement String for the specified String. This method
            produces a String that will work as a literal replacement s in the
            appendReplacement method of the Matcher class.
          </td>
        </tr>
      </table>
      <h2>The <i>start</i> and <i>end</i> Methods:</h2>
      <p>
        Following is the example that counts the number of times the word "cats"
        appears in the input string:
      </p>
      <pre class="prettyprint">
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches
{
    private static final String REGEX = "\\bcat\\b";
    private static final String INPUT =
                                    "cat cat cat cattie cat";

    public static void main( String args[] ){
       Pattern p = Pattern.compile(REGEX);
       Matcher m = p.matcher(INPUT); // get a matcher object
       int count = 0;

       while(m.find()) {
         count++;
         System.out.println("Match number "+count);
         System.out.println("start(): "+m.start());
         System.out.println("end(): "+m.end());
      }
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
Match number 1
start(): 0
end(): 3
Match number 2
start(): 4
end(): 7
Match number 3
start(): 8
end(): 11
Match number 4
start(): 19
end(): 22
</pre
      >
      <p>
        You can see that this example uses word boundaries to ensure that the
        letters "c" "a" "t" are not merely a substring in a longer word. It also
        gives some useful information about where in the input string the match
        has occurred.
      </p>
      <p>
        The start method returns the start index of the subsequence captured by
        the given group during the previous match operation, and end returns the
        index of the last character matched, plus one.
      </p>
      <h2>The <i>matches</i> and <i>lookingAt</i> Methods:</h2>
      <p>
        The matches and lookingAt methods both attempt to match an input
        sequence against a pattern. The difference, however, is that matches
        requires the entire input sequence to be matched, while lookingAt does
        not.
      </p>
      <p>
        Both methods always start at the beginning of the input string. Here is
        the example explaining the functionality:
      </p>
      <pre class="prettyprint">
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches
{
    private static final String REGEX = "foo";
    private static final String INPUT = "fooooooooooooooooo";
    private static Pattern pattern;
    private static Matcher matcher;

    public static void main( String args[] ){
       pattern = Pattern.compile(REGEX);
       matcher = pattern.matcher(INPUT);

       System.out.println("Current REGEX is: "+REGEX);
       System.out.println("Current INPUT is: "+INPUT);

       System.out.println("lookingAt(): "+matcher.lookingAt());
       System.out.println("matches(): "+matcher.matches());
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
Current REGEX is: foo
Current INPUT is: fooooooooooooooooo
lookingAt(): true
matches(): false
</pre
      >
      <h2>The <i>replaceFirst</i> and <i>replaceAll</i> Methods:</h2>
      <p>
        The replaceFirst and replaceAll methods replace text that matches a
        given regular expression. As their names indicate, replaceFirst replaces
        the first occurrence, and replaceAll replaces all occurences.
      </p>
      <p>Here is the example explaining the functionality:</p>
      <pre class="prettyprint">
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches
{
    private static String REGEX = "dog";
    private static String INPUT = "The dog says meow. " +
                                    "All dogs say meow.";
    private static String REPLACE = "cat";

    public static void main(String[] args) {
       Pattern p = Pattern.compile(REGEX);
       // get a matcher object
       Matcher m = p.matcher(INPUT); 
       INPUT = m.replaceAll(REPLACE);
       System.out.println(INPUT);
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
The cat says meow. All cats say meow.
</pre
      >
      <h2>The <i>appendReplacement</i> and <i>appendTail</i> Methods:</h2>
      <p>
        The Matcher class also provides appendReplacement and appendTail methods
        for text replacement.
      </p>
      <p>Here is the example explaining the functionality:</p>
      <pre class="prettyprint">
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches
{
   private static String REGEX = "a*b";
   private static String INPUT = "aabfooaabfooabfoob";
   private static String REPLACE = "-";
   public static void main(String[] args) {
      Pattern p = Pattern.compile(REGEX);
      // get a matcher object
      Matcher m = p.matcher(INPUT);
      StringBuffer sb = new StringBuffer();
      while(m.find()){
         m.appendReplacement(sb,REPLACE);
      }
      m.appendTail(sb);
      System.out.println(sb.toString());
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
-foo-foo-foo-
</pre
      >
      <h2>PatternSyntaxException Class Methods:</h2>
      <p>
        A PatternSyntaxException is an unchecked exception that indicates a
        syntax error in a regular expression pattern. The PatternSyntaxException
        class provides the following methods to help you determine what went
        wrong:
      </p>
      <table class="src">
        <tr>
          <th>SN</th>
          <th>Methods with Description</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b>public String getDescription()</b><br />Retrieves the description
            of the error.
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td><b>public int getIndex() </b><br />Retrieves the error index.</td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>public String getPattern() </b><br />Retrieves the erroneous
            regular expression pattern.
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>public String getMessage() </b><br />Returns a multi-line string
            containing the description of the syntax error and its index, the
            erroneous regular expression pattern, and a visual indication of the
            error index within the pattern.
          </td>
        </tr>
      </table>
      <br />
      <hr />
      <div class="pre-btn">
        <a href="/java/java_date_time.htm">Previous Page</a>
      </div>
      <div class="print-btn">
        <a href="/cgi-bin/printpage.cgi" target="_blank">Print Version</a>
      </div>
      <div class="pdf-btn">
        <a
          href="/java/pdf/java_regular_expressions.pdf"
          alt="Java - Regular Expressions"
          target="_blank"
          >PDF Version</a
        >
      </div>
      <div class="nxt-btn">
        <a href="/java/java_methods.htm">Next Page</a>
      </div>
      <div class="clearer"></div>
      <hr />
    </div>
    <!-- PRINTING ENDS HERE -->
  </body>
</html>
