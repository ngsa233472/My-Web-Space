<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 TRANSITIONAL//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Fedora Server Installation</title>
    <link
      rel="stylesheet"
      type="text/css"
      media="screen,print"
      href="/stylesheets/Welcome./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="/stylesheets/install./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="./install./css/fedora_install.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="../install./css/fedora_install.css"
    />
    <meta status="incomplete" />
  </head>
  <body>
    <h2><a>Default</a></h2>

    <!-- PRINTING STARTS HERE -->
    <div class="content">
      <h1>Java - Multithreading</h1>
      <div class="topgooglead">
        <div style="padding-bottom: 5px; padding-left: 10px">
          Advertisements
        </div>
        <script type="text/javascript">
          <!--
          google_ad_client = "pub-7133395778201029";
          google_ad_width = 468;
          google_ad_height = 60;
          google_ad_format = "468x60_as";
          google_ad_type = "image";
          google_ad_channel = "";
          //-->
        </script>
        <script
          type="text/javascript"
          src="http://pagead2.googlesyndication.com/pagead/show_ads.js"
        ></script>
      </div>
      <hr />
      <div class="pre-btn">
        <a href="/java/java_sending_email.htm">Previous Page</a>
      </div>
      <div class="nxt-btn">
        <a href="/java/java_applet_basics.htm">Next Page</a>
      </div>
      <div class="clearer"></div>
      <hr />
      <p>
        Java provides built-in support for <i>multithreaded programming</i>. A
        multithreaded program contains two or more parts that can run
        concurrently. Each part of such a program is called a thread, and each
        thread defines a separate path of execution.
      </p>
      <p>
        A multithreading is a specialized form of multitasking. Multitasking
        threads require less overhead than multitasking processes.
      </p>
      <p>
        I need to define another term related to threads: <b>process:</b> A
        process consists of the memory space allocated by the operating system
        that can contain one or more threads. A thread cannot exist on its own;
        it must be a part of a process. A process remains running until all of
        the non-daemon threads are done executing.
      </p>
      <p>
        Multithreading enables you to write very efficient programs that make
        maximum use of the CPU, because idle time can be kept to a minimum.
      </p>
      <h2>Life Cycle of a Thread:</h2>
      <p>
        A thread goes through various stages in its life cycle. For example, a
        thread is born, started, runs, and then dies. Following diagram shows
        complete life cycle of a thread.
      </p>
      <center>
        <img src="/images/java_thread.jpg" alt="Java Thread" />
      </center>
      <p>Above mentioned stages are explained here:</p>
      <ul class="list">
        <li>
          <p>
            <b>New:</b> A new thread begins its life cycle in the new state. It
            remains in this state until the program starts the thread. It is
            also referred to as a born thread.
          </p>
        </li>
        <li>
          <p>
            <b>Runnable:</b> After a newly born thread is started, the thread
            becomes runnable. A thread in this state is considered to be
            executing its task.
          </p>
        </li>
        <li>
          <p>
            <b>Waiting:</b> Sometimes a thread transitions to the waiting state
            while the thread waits for another thread to perform a task.A thread
            transitions back to the runnable state only when another thread
            signals the waiting thread to continue executing.
          </p>
        </li>
        <li>
          <p>
            <b>Timed waiting:</b> A runnable thread can enter the timed waiting
            state for a specified interval of time. A thread in this state
            transitions back to the runnable state when that time interval
            expires or when the event it is waiting for occurs.
          </p>
        </li>
        <li>
          <p>
            <b>Terminated: </b> A runnable thread enters the terminated state
            when it completes its task or otherwise terminates.
          </p>
        </li>
      </ul>
      <h2>Thread Priorities:</h2>
      <p>
        Every Java thread has a priority that helps the operating system
        determine the order in which threads are scheduled.
      </p>
      <p>
        Java priorities are in the range between MIN_PRIORITY (a constant of 1)
        and MAX_PRIORITY (a constant of 10). By default, every thread is given
        priority NORM_PRIORITY (a constant of 5).
      </p>
      <p>
        Threads with higher priority are more important to a program and should
        be allocated processor time before lower-priority threads. However,
        thread priorities cannot guarantee the order in which threads execute
        and very much platform dependentant.
      </p>
      <h2>Creating a Thread:</h2>
      <p>Java defines two ways in which this can be accomplished:</p>
      <ul class="list">
        <li><p>You can implement the Runnable interface.</p></li>
        <li><p>You can extend the Thread class, itself.</p></li>
      </ul>
      <h2>Create Thread by Implementing Runnable:</h2>
      <p>
        The easiest way to create a thread is to create a class that implements
        the <b>Runnable</b> interface.
      </p>
      <p>
        To implement Runnable, a class need only implement a single method
        called <b>run( )</b>, which is declared like this:
      </p>
      <pre class="prettyprint">
public void run( )
</pre
      >
      <p>
        You will define the code that constitutes the new thread inside run()
        method. It is important to understand that run() can call other methods,
        use other classes, and declare variables, just like the main thread can.
      </p>
      <p>
        After you create a class that implements Runnable, you will instantiate
        an object of type Thread from within that class. Thread defines several
        constructors. The one that we will use is shown here:
      </p>
      <pre class="prettyprint">
Thread(Runnable threadOb, String threadName);
</pre
      >
      <p>
        Here <i>threadOb</i> is an instance of a class that implements the
        Runnable interface and the name of the new thread is specified by
        <i>threadName</i>.
      </p>
      <p>
        After the new thread is created, it will not start running until you
        call its <b>start( )</b> method, which is declared within Thread. The
        start( ) method is shown here:
      </p>
      <pre class="prettyprint">
void start( );
</pre
      >
      <h2>Example:</h2>
      <p>Here is an example that creates a new thread and starts it running:</p>
      <pre class="prettyprint">
// Create a new thread.
class NewThread implements Runnable {
   Thread t;
   NewThread() {
      // Create a new, second thread
      t = new Thread(this, "Demo Thread");
      System.out.println("Child thread: " + t);
      t.start(); // Start the thread
   }
   
   // This is the entry point for the second thread.
   public void run() {
      try {
         for(int i = 5; i &gt; 0; i--) {
            System.out.println("Child Thread: " + i);
            // Let the thread sleep for a while.
            Thread.sleep(500);
         }
     } catch (InterruptedException e) {
         System.out.println("Child interrupted.");
     }
     System.out.println("Exiting child thread.");
   }
}

public class ThreadDemo {
   public static void main(String args[]) {
      new NewThread(); // create a new thread
      try {
         for(int i = 5; i &gt; 0; i--) {
           System.out.println("Main Thread: " + i);
           Thread.sleep(1000);
         }
      } catch (InterruptedException e) {
         System.out.println("Main thread interrupted.");
      }
      System.out.println("Main thread exiting.");
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
Child thread: Thread[Demo Thread,5,main]
Main Thread: 5
Child Thread: 5
Child Thread: 4
Main Thread: 4
Child Thread: 3
Child Thread: 2
Main Thread: 3
Child Thread: 1
Exiting child thread.
Main Thread: 2
Main Thread: 1
Main thread exiting.
</pre
      >
      <h2>Create Thread by Extending Thread:</h2>
      <p>
        The second way to create a thread is to create a new class that extends
        <b>Thread</b>, and then to create an instance of that class.
      </p>
      <p>
        The extending class must override the <b>run( )</b> method, which is the
        entry point for the new thread. It must also call <b>start( )</b> to
        begin execution of the new thread.
      </p>
      <h2>Example:</h2>
      <p>Here is the preceding program rewritten to extend Thread:</p>
      <pre class="prettyprint">
// Create a second thread by extending Thread
class NewThread extends Thread {
   NewThread() {
      // Create a new, second thread
      super("Demo Thread");
      System.out.println("Child thread: " + this);
      start(); // Start the thread
   }

   // This is the entry point for the second thread.
   public void run() {
      try {
         for(int i = 5; i &gt; 0; i--) {
            System.out.println("Child Thread: " + i);
			// Let the thread sleep for a while.
            Thread.sleep(500);
         }
      } catch (InterruptedException e) {
         System.out.println("Child interrupted.");
      }
      System.out.println("Exiting child thread.");
   }
}

public class ExtendThread {
   public static void main(String args[]) {
      new NewThread(); // create a new thread
      try {
         for(int i = 5; i &gt; 0; i--) {
            System.out.println("Main Thread: " + i);
            Thread.sleep(1000);
         }
      } catch (InterruptedException e) {
         System.out.println("Main thread interrupted.");
      }
      System.out.println("Main thread exiting.");
   }
}
</pre
      >
      <p>This would produce following result:</p>
      <pre class="prettyprint">
Child thread: Thread[Demo Thread,5,main]
Main Thread: 5
Child Thread: 5
Child Thread: 4
Main Thread: 4
Child Thread: 3
Child Thread: 2
Main Thread: 3
Child Thread: 1
Exiting child thread.
Main Thread: 2
Main Thread: 1
Main thread exiting.
</pre
      >
      <h2>Thread Methods:</h2>
      <p>
        Following is the list of important medthods available in the Thread
        class.
      </p>
      <table class="src">
        <tr>
          <th>SN</th>
          <th>Methods with Description</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b>public void start()</b><br />Starts the thread in a separate path
            of execution, then invokes the run() method on this Thread object.
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <b>public void run()</b><br />If this Thread object was instantiated
            using a separate Runnable target, the run() method is invoked on
            that Runnable object.
          </td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>public final void setName(String name)</b><br />Changes the name
            of the Thread object. There is also a getName() method for
            retrieving the name.
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>public final void setPriority(int priority)</b><br />Sets the
            priority of this Thread object. The possible values are between 1
            and 10.
          </td>
        </tr>
        <tr>
          <td>5</td>
          <td>
            <b>public final void setDaemon(boolean on)</b><br />A parameter of
            true denotes this Thread as a daemon thread.
          </td>
        </tr>
        <tr>
          <td>6</td>
          <td>
            <b>public final void join(long millisec)</b><br />The current thread
            invokes this method on a second thread, causing the current thread
            to block until the second thread terminates or the specified number
            of milliseconds passes.
          </td>
        </tr>
        <tr>
          <td>7</td>
          <td>
            <b>public void interrupt()</b><br />Interrupts this thread, causing
            it to continue execution if it was blocked for any reason.
          </td>
        </tr>
        <tr>
          <td>8</td>
          <td>
            <b>public final boolean isAlive()</b><br />Returns true if the
            thread is alive, which is any time after the thread has been started
            but before it runs to completion.
          </td>
        </tr>
      </table>
      <p>
        The previous methods are invoked on a particular Thread object. The
        following methods in the Thread class are static. Invoking one of the
        static methods performs the operation on the currently running thread
      </p>
      <table class="src">
        <tr>
          <th>SN</th>
          <th>Methods with Description</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <b>public static void yield()</b><br />Causes the currently running
            thread to yield to any other threads of the same priority that are
            waiting to be scheduled
          </td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <b>public static void sleep(long millisec)</b><br />Causes the
            currently running thread to block for at least the specified number
            of milliseconds
          </td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <b>public static boolean holdsLock(Object x)</b><br />Returns true
            if the current thread holds the lock on the given Object.
          </td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <b>public static Thread currentThread()</b><br />Returns a reference
            to the currently running thread, which is the thread that invokes
            this method.
          </td>
        </tr>
        <tr>
          <td>5</td>
          <td>
            <b>public static void dumpStack()</b><br />Prints the stack trace
            for the currently running thread, which is useful when debugging a
            multithreaded application.
          </td>
        </tr>
      </table>
      <h2>Example:</h2>
      <p>
        The following ThreadClassDemo program demonstrates some of these methods
        of the Thread class:
      </p>
      <pre class="prettyprint">
// File Name : DisplayMessage.java
// Create a thread to implement Runnable
public class DisplayMessage implements Runnable
{
   private String message;
   public DisplayMessage(String message)
   {
      this.message = message;
   }
   public void run()
   {
      while(true)
      {
         System.out.println(message);
      }
   }
}

// File Name : GuessANumber.java
// Create a thread to extentd Thread
public class GuessANumber extends Thread
{
   private int number;
   public GuessANumber(int number)
   {
      this.number = number;
   }
   public void run()
   {
      int counter = 0;
      int guess = 0;
      do
      {
          guess = (int) (Math.random() * 100 + 1);
          System.out.println(this.getName()
                       + " guesses " + guess);
          counter++;
      }while(guess != number);
      System.out.println("** Correct! " + this.getName()
                       + " in " + counter + " guesses.**");
   }
}

// File Name : ThreadClassDemo.java
public class ThreadClassDemo
{
   public static void main(String [] args)
   {
      Runnable hello = new DisplayMessage("Hello");
      Thread thread1 = new Thread(hello);
      thread1.setDaemon(true);
      thread1.setName("hello");
      System.out.println("Starting hello thread...");
      thread1.start();
      
      Runnable bye = new DisplayMessage("Goodbye");
      Thread thread2 = new Thread(hello);
      thread2.setPriority(Thread.MIN_PRIORITY);
      thread2.setDaemon(true);
      System.out.println("Starting goodbye thread...");
      thread2.start();

      System.out.println("Starting thread3...");
      Thread thread3 = new GuessANumber(27);
      thread3.start();
      try
      {
         thread3.join();
      }catch(InterruptedException e)
      {
         System.out.println("Thread interrupted.");
      }
      System.out.println("Starting thread4...");
      Thread thread4 = new GuessANumber(75);
      
	  thread4.start();
      System.out.println("main() is ending...");
   }
}
</pre
      >
      <p>
        This would produce following result. You can try this example again and
        again and you would get different result every time.
      </p>
      <pre class="prettyprint">
Starting hello thread...
Starting goodbye thread...
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Thread-2 guesses 27
Hello
** Correct! Thread-2 in 102 guesses.**
Hello
Starting thread4...
Hello
Hello
..........remaining result produced.
</pre
      >
      <h2>Major Thread Concepts:</h2>
      <p>
        While doing Multithreading programming, you would need to have following
        concepts very handy:
      </p>
      <ul class="list">
        <li>
          <p>
            <a href="/java/java_thread_synchronization.htm"
              >Thread Synchronization</a
            >
          </p>
        </li>
        <li>
          <p>
            <a href="/java/java_thread_communication.htm"
              >Interthread Communication</a
            >
          </p>
        </li>
        <li>
          <p><a href="/java/java_thread_deadlock.htm">Thread Deadlock</a></p>
        </li>
        <li>
          <p>
            <a href="/java/java_thread_control.htm"
              >Thread Control: Suspend, Stop and Resume</a
            >
          </p>
        </li>
      </ul>
      <h2>Using Multithreading:</h2>
      <p>
        The key to utilizing multithreading support effectively is to think
        concurrently rather than serially. For example, when you have two
        subsystems within a program that can execute concurrently, make them
        individual threads.
      </p>
      <p>
        With the careful use of multithreading, you can create very efficient
        programs. A word of caution is in order, however: If you create too many
        threads, you can actually degrade the performance of your program rather
        than enhance it.
      </p>
      <p>
        Remember, some overhead is associated with context switching. If you
        create too many threads, more CPU time will be spent changing contexts
        than executing your program!
      </p>
      <br />
      <hr />
      <div class="pre-btn">
        <a href="/java/java_sending_email.htm">Previous Page</a>
      </div>
      <div class="print-btn">
        <a href="/cgi-bin/printpage.cgi" target="_blank">Print Version</a>
      </div>
      <div class="pdf-btn">
        <a
          href="/java/pdf/java_multithreading.pdf"
          alt="Java - Multithreading Programming Tutorial"
          target="_blank"
          >PDF Version</a
        >
      </div>
      <div class="nxt-btn">
        <a href="/java/java_applet_basics.htm">Next Page</a>
      </div>
      <div class="clearer"></div>
      <hr />
    </div>
    <!-- PRINTING ENDS HERE -->
  </body>
</html>
